{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ducklib","text":""},{"location":"#why-ducklib","title":"Why ducklib?","text":"<p>Ducklib is a library made by team 14343 Escape Velocity meant to be good at scheduling commands. It's an alternative to Roadrunner Actions, FTCLib, and Dairy (at least Util and Mercurial).</p> <p>It's made to be ergonomic for most common tasks, to have a rich scheduling system while being still intuitive to those coming from FTCLib, to use idiomatic Kotlin patterns, and to keep your code concise and readable, allowing you to focus more on what you want and now how you do it.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>installation</li> <li>commands</li> <li>gamepads</li> <li>hardware maps (aka how to avoid NPEs)</li> <li>Example TeleOp</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Required:</p> <ul> <li>git</li> <li>some knowledge of Gradle build scripts</li> </ul>"},{"location":"installation/#step-1-cloning-ftcrobotcontroller","title":"Step 1: Cloning FtcRobotController","text":"<p>First, clone the FtcRobotController repo if you haven't already:</p> <pre><code>git clone https://github.com/FIRST-Tech-Challenge/FtcRobotController\n</code></pre>"},{"location":"installation/#step-2-cloning-ducklib","title":"Step 2: Cloning ducklib","text":"<p>Now, we'll clone ducklib into the same directory you cloned FtcRobotController into:</p> <pre><code>git clone https://github.com/escape-velocity-14343/ducklib\n</code></pre> <p>Now, your file tree should look something like this:</p> <pre><code>FTC projects folder\n\u251c FtcRobotController\n\u2502 \u251c TeamCode\n\u2502 \u251c FtcRobotController\n\u2502 ...\n\u2514 ducklib\n  \u251c ducklib\n  \u251c ducklib-ftc\n  \u251c ducklib-test\n  \u251c docs\n  ...\n</code></pre> <p>We're going to be using <code>includeBuild</code> to include a dependency to another project.</p>"},{"location":"installation/#step-3-add-projects-to-ftcrobotcontroller","title":"Step 3: Add projects to <code>FtcRobotController</code>","text":"<p>Now, open the <code>settings.gradle</code> file in <code>FtcRobotController</code>. You should have something like this by default:</p> <pre><code>include ':FtcRobotController'\ninclude ':TeamCode'\n</code></pre> <p>Now, add</p> <pre><code>includeBuild(\"../ducklib/ducklib\") {\n    dependencySubstitution {\n        substitute module(\"com.escapevelocity.ducklib:core\") using project(\":\")\n    }\n}\n\nincludeBuild(\"../ducklib/ducklib-ftc\") {\n    dependencySubstitution {\n        substitute module(\"com.escapevelocity.ducklib:ftc\") using project(\":\")\n    }\n}\n</code></pre> <p>to the end. This will tell Gradle to include the ducklib projects in the build as well as the normal TeamCode projects, with the package name <code>com.escapevelocity.ducklib:&lt;core/ftc&gt;</code></p>"},{"location":"installation/#step-4-add-ducklib-as-a-dependency","title":"Step 4: Add ducklib as a dependency","text":"<p>Now, you're ready to add ducklib as a dependency. Open up <code>build.gradle</code> in <code>FtcRobotController/TeamCode</code>, and add ducklib as a dependency inside the dependency block:</p> <pre><code>dependencies {\n    implementation project(':FtcRobotController')\n    implementation 'com.escapevelocity.ducklib:core'\n    implementation 'com.escapevelocity.ducklib:ftc'\n}\n</code></pre> <p>The whole <code>FtcRobotController/TeamCode/build.gradle</code> should look like this:</p> <pre><code>apply from: '../build.common.gradle'\napply from: '../build.dependencies.gradle'\napply plugin: 'org.jetbrains.kotlin.android'\n\nandroid {\n    namespace = 'org.firstinspires.ftc.teamcode'\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n\n    packagingOptions {\n        jniLibs.useLegacyPackaging true\n    }\n}\n\ndependencies {\n    implementation project(':FtcRobotController')\n    implementation 'com.escapevelocity.ducklib:core'\n    implementation 'com.escapevelocity.ducklib:ftc'\n}\n</code></pre> <p>Run a Gradle sync (tip: open up the command palette to run any action by double-pressing shift) and there shouldn't be any errors. ducklib should be ready to use!</p>"},{"location":"Commands/builtin/","title":"Built-in commands","text":"<p>ducklib comes with a number of commands built in as basic utilities.</p>"},{"location":"Commands/builtin/#atomic-commands","title":"Atomic commands","text":""},{"location":"Commands/builtin/#instantcommand","title":"<code>InstantCommand</code>","text":"<p>It runs a lambda once in <code>execute</code> and then stops.</p> <p>Example usage:</p> <pre><code>val cmd = InstantCommand { println(\"duck\") }\n</code></pre> <p>Alternatively, with the decorator:</p> <pre><code>val cmd = { println(\"duck\") }.instant()\n</code></pre> <p>You can also give both of these a set of requirements:</p> <pre><code>val cmd = InstantCommand(requirement) { println(\"duck\") }\n</code></pre> <pre><code>val cmd = { println(\"duck\") }.instant(requirement)\n</code></pre>"},{"location":"Commands/builtin/#loopcommand","title":"<code>LoopCommand</code>","text":"<p>Not to be confused with <code>RepeatCommand</code>, it calls the given lambda repeatedly forever. Think if it like a non-instant <code>InstantCommand</code>.</p> <p>Example usage:</p> <pre><code>val cmd = LoopCommand { println(\"duck\") }\n</code></pre> <p>Alternatively, with the decorator:</p> <pre><code>val cmd = { println(\"duck\") }.loop()\n</code></pre> <p>You can also give both of these a set of requirements:</p> <pre><code>val cmd = LoopCommand(requirement) { println(\"duck\") }\n</code></pre> <pre><code>val cmd = { println(\"duck\") }.loop(requirement)\n</code></pre> <p>If you want to repeat a lambda finitely, compose an <code>InstantCommand</code> inside a <code>RepeatCommand</code> instead.</p>"},{"location":"Commands/builtin/#noopcommand","title":"<code>NoOpCommand</code>","text":"<p>it does nothing, like me.</p>"},{"location":"Commands/builtin/#waitcommand","title":"<code>WaitCommand</code>","text":"<p>It waits for a given number of seconds, optionally accounting for suspension time as well (e.g. if it has a 2 second timer, has been running for 1 second, gets suspended for 5 seconds, then resumes, it'll continue waiting for 1 second)</p>"},{"location":"Commands/builtin/#waituntilcommand","title":"<code>WaitUntilCommand</code>","text":"<p>It waits until a condition is true.</p>"},{"location":"Commands/builtin/#lambdacommand","title":"<code>LambdaCommand</code>","text":"<p>A command that delegates the functions to lambda-typed properties.</p> <p>It's useful for creating inline one-off commands that don't really get used anywhere else.</p> <p>For example, a driving command that captures a subsystem reference and gamepad in the lambda:</p> <pre><code>LambdaCommand {\n    // add the requirements of the drivetrain subsystem\n    // so that other commands that share that will suspend this command\n    addRequirements(drivetrainSubsystem)\n    lmexecute = {\n        // driver gamepad references don't need suppliers since it's wrapped in a lambda\n        drivetrainSubsystem.drive(\n            driver[VectorInput.STICK_LEFT].flip(Axis.Y),\n            driver[AnalogInput.STICK_X_LEFT].radians\n        )\n    }\n    lmfinished = { false }\n}.schedule()\n</code></pre> <p>You can also capture state inside of the configuration lambda, removing the need for a <code>StatefulLambda</code> like Mercurial has:</p> <pre><code>LambdaCommand {\n    var i = 0\n    lminitialize = { i = 0 }\n    lmexecute = { i += 1 }\n    lmfinished = { i &gt;= 5 }\n}\n</code></pre>"},{"location":"Commands/builtin/#compositions","title":"Compositions","text":"<p>Composition commands compose a set of commands, inheriting most of their functionality while overriding specific actions.</p>"},{"location":"Commands/builtin/#deferredcommand","title":"<code>DeferredCommand</code>","text":"<p><code>DeferredCommand</code> defers command construction (through <code>commandSupplier</code>) until initialization time. It's useful when you're making a command that has dynamically changing values, such as a path generator.</p> <p>Example usage: <pre><code>val cmd = DeferredCommand { WaitCommand(getSomeDynamicWaitTime()) }\n</code></pre> In this example, construction of the <code>WaitCommand</code> is deferred until the command is initialized, so even though <code>WaitCommand</code> doesn't accept a time supplier, the amount of time it waits can change. Note how this is fundamentally different from <pre><code>val cmd = WaitCommand(getSomeDynamicWaitTime())\n</code></pre> since that will compute the wait time once and use that every time it's scheduled.</p>"},{"location":"Commands/builtin/#ifcommand-ifelsecommand-and-whencommand","title":"<code>IfCommand</code>, <code>IfElseCommand</code>, and <code>WhenCommand</code>","text":"<p><code>IfCommand</code> runs a command if, at initialization time, the provided supplier returns <code>true</code>.</p> <p>Example usage: <pre><code>val cmd = IfCommand({ slidesRetracted }, extend())\n</code></pre> In this example, if <code>slidesRetracted</code> is <code>true</code>, if the command is run something will extend, otherwise nothing will happen.</p> <p><code>IfElseCommand</code> runs a command if, at initialization time, the provided supplier returns <code>true</code>, otherwise it runs the other command.</p> <p>Example usage: <pre><code>val cmd = IfCommand({ slidesRetracted }, extend(), retract())\n</code></pre> In this example, if <code>slidesRetracted</code> is <code>true</code>, if the command is run something will extend, otherwise something will retract.</p> <p><code>WhenCommand</code> selects a command to run based on the provided supplier.</p> <p>Example usage: <pre><code>val cmd = WhenCommand { state }.configure {\n    this[State.READY] = outtake()\n    this[State.INTAKE] = retract() then outtake()\n    this[State.HANG] = retract() then outtake()\n    default = retract()\n}\n</code></pre> For more information on the <code>configure</code> method, see configure</p> <p>It also has an alternative syntax:</p> <pre><code>val cmd = WhenCommand(\n    State.READY to outtake(),\n    State.INTAKE to retract() then outtake(),\n    State.HANG to retract() then outtake(),\n    default = retract()\n) { state }\n</code></pre>"},{"location":"Commands/builtin/#timeoutcommand","title":"<code>TimeoutCommand</code>","text":"<p><code>TimeoutCommand</code> adds a timeout to the command.</p> <p>Example usage</p> <pre><code>val cmd = TimeoutCommand(WaitCommand(5.seconds), 3.seconds)\n</code></pre> <p>Alternatively, use the decorator:</p> <pre><code>val cmd = WaitCommand(5.seconds).withTimeout(3.seconds)\n</code></pre>"},{"location":"Commands/builtin/#repeatcommand","title":"<code>RepeatCommand</code>","text":"<p><code>RepeatCommand</code> runs a command repeatedly, either for some finite number of repeats, or forever.</p> <p>Example usage:</p> <pre><code>// repeat 3 times\nval cmd = RepeatCommand(WaitCommand(3.seconds), 3)\n</code></pre> <pre><code>// repeat infinite times\nval cmd = RepeatCommand(WaitCommand(3.seconds))\n</code></pre> <p>Alternatively, use the decorator:</p> <pre><code>// repeat 3 times\nval cmd = WaitCommand(3.seconds).repeat(3)\n</code></pre> <pre><code>// repeat infinite times\nval cmd = WaitCommand(3.seconds).forever\n</code></pre> <p>This is especially useful for <code>InstantCommand</code>s:</p> <pre><code>val cmd = { println(\"duck!\") }.instant().forever\n</code></pre>"},{"location":"Commands/builtin/#groups","title":"Groups","text":"<p>See command groups</p>"},{"location":"Commands/custom/","title":"Custom commands","text":""},{"location":"Commands/custom/#why-custom-commands","title":"Why custom commands?","text":""},{"location":"Commands/groups/","title":"Command groups","text":""},{"location":"Commands/groups/#introduction","title":"Introduction","text":"<p>Command groups are a special type of composing command that group together commands in useful ways.</p>"},{"location":"Commands/groups/#sequentialcommandgroup","title":"<code>SequentialCommandGroup</code>","text":"<p>The most common type of command group. It runs a set of commands, one after the other, and finishes when the last one finishes.</p> <p>For example, a command that says \"hi\", waits 5 seconds, then says \"bye\":</p> <pre><code>val cmd = SequentialCommandGroup(\n    { println(\"hi\") }.instant(),\n    WaitCommand(5.seconds),\n    { println(\"bye\") }.instant(),\n)\n</code></pre> <p>You can also construct this with the <code>then</code> infix operator:</p> <pre><code>val cmd = { println(\"hi\") }.instant() then WaitCommand(5.seconds) and { println(\"bye\") }.instant()\n</code></pre>"},{"location":"Commands/groups/#parallelcommandgroup","title":"<code>ParallelCommandGroup</code>","text":"<p>The second most common type of command group. It runs a set of commands all at the same time, and finishes when they're all finished.</p> <p>For example, a command that says \"hi\" and \"bye\" at the same time:</p> <pre><code>val cmd = ParallelCommandGroup(\n    { println(\"hi\") }.instant(),\n    { println(\"bye\") }.instant(),\n)\n</code></pre> <p>You can also construct this with the <code>with</code> infix operator:</p> <pre><code>val cmd = { println(\"hi\") }.instant() with { println(\"bye\") }.instant()\n</code></pre>"},{"location":"Commands/groups/#parallelcommandgroup-like-groups","title":"<code>ParallelCommandGroup</code>-like groups","text":"<p>There are a bunch of groups that act similar to <code>ParallelCommandGroup</code> but have different end conditions.</p>"},{"location":"Commands/groups/#racecommandgroup","title":"<code>RaceCommandGroup</code>","text":"<p>This group runs all the commands at the same time and ends when any one of them ends.</p> <p>For example, a group that waits for 4 seconds:</p> <pre><code>val cmd = RaceCommandGroup(\n    WaitCommand(4.seconds),\n    WaitCommand(5.seconds),\n)\n</code></pre> <p>You can also construct this with the <code>races</code> infix operator:</p> <pre><code>val cmd = WaitCommand(4.seconds) races WaitCommand(5.seconds) and WaitCommand(6.seconds)\n</code></pre>"},{"location":"Commands/groups/#deadlinecommandgroup","title":"<code>DeadlineCommandGroup</code>","text":"<p>This group ends when the \"deadline\" command finishes.</p> <p>For example, a group that runs for exactly 5 seconds all the while printing \"duck\":</p> <pre><code>val cmd = DeadlineCommandGroup(\n    WaitCommand(5.seconds),\n    { println(\"duck\") }.loop()\n)\n</code></pre> <p>A group that runs for 5 seconds but only prints \"duck\" onceL</p> <pre><code>val cmd = DeadlineCommandGroup(\n    WaitCommand(5.seconds),\n    { println(\"duck\") }.instant()\n)\n</code></pre> <p>You can also construct this with the <code>deadlines</code> operator. Note that unlike the <code>then</code>, <code>with</code>, <code>parallel</code>, and <code>races</code> operators, you have to use <code>and</code> to chain multiple commands in the group.</p> <pre><code>val cmd = WaitCommand(5.seconds) deadlines { println(\"duck\") }.loop()\n</code></pre> <p>Also, <code>DeadlineCommandGroup</code>s may seem very similar to <code>RaceCommandGroup</code> but they are not the same. <code>RaceCommandGroup</code> ends when any of the commands end, but <code>DeadlineCommandGroup</code> only ends when the deadline command ends.</p>"},{"location":"Commands/groups/#infix-operators","title":"Infix operators","text":"<p>Command groups also have some utility infix operators that make your command groups read more like English. They are as follows:</p> <ul> <li><code>then</code>: SequentialCommandGroup</li> <li><code>with</code>: ParallelCommandGroup</li> <li><code>races</code>: RaceCommandGroup</li> <li><code>deadlines</code>: DeadlineCommandGroup</li> <li><code>and</code>: Adds the command on the right to the command group on the left</li> </ul> <p>Like all Kotlin infix operators, they all have the same precedence and are left-associative. This means that</p> <pre><code>cmd1 then cmd2 with cmd3 and cmd4 deadlines cmd5\n</code></pre> <p>is parsed as</p> <pre><code>(((cmd1 then cmd2) with cmd3) and cmd4) deadlines cmd5\n</code></pre> <p>and no other way.</p> <p><code>then</code>, <code>with</code>, and <code>races</code> will automatically check if the command on the left is a group of the right type, and if it is, it adds the command on the right instead of creating nested groups. However, this doesn't work with DeadlineCommandGroup because the command on the left is always the deadline command, so you have to use <code>and</code> with that one.</p> <p>In my opinion, <code>and</code> makes the code easier to read, so I suggest using it. For example, this:</p> <pre><code>cmd1 with cmd2 and cmd3 and cmd3\n</code></pre> <p>is more readable than</p> <pre><code>cmd1 with cmd2 with cmd3 with cmd4\n</code></pre>"},{"location":"Commands/introduction/","title":"Introduction","text":""},{"location":"Commands/introduction/#overview","title":"Overview","text":"<p>A command represents an action. For example, an action that waits for 2 seconds:</p> <pre><code>val cmd = WaitCommand(2.0.seconds)\n</code></pre> <p>A command that runs a specified action:</p> <p><pre><code>val cmd = InstantCommand {  println(\"ducky!\") }\n</code></pre> More info on built-in commands</p> <p>A user-made command that drives the robot around:</p> <p><pre><code>val cmd = DriveCommand(mecanum, Vector2(3.inches, 5.inches))\n</code></pre> More info on custom commands</p> <p>A command that runs all of those commands in sequence</p> <p><pre><code>val cmd = SequentialCommandGroup(\n    WaitCommand(2.0.seconds),\n    InstantCommand {  println(\"ducky!\") },\n    DriveCommand(mecanum, Vector2(3.inches, 5.inches)),\n)\n</code></pre> More info on command groups</p> <p>Commands are extremely flexible because each one represents a single unit of work, and they can be composed in groups to make entire autonomi.</p> <p>Commands are run by the command scheduler. Commands can also optionally have a set of requirements and a priority.</p>"},{"location":"Commands/introduction/#lifetime-functions","title":"Lifetime functions","text":"<p>Every command overrides a set of lifetime functions, which (in calling order) are:</p>"},{"location":"Commands/introduction/#initialize","title":"<code>initialize</code>","text":"<p>This gets called as soon as the command gets actually scheduled, so if the scheduling gets deferred (e.g. by attempting to schedule it while the scheduler is processing commands) it'll wait until the deferred calls get run. It gets run every time the command is initialized, not just the first time.</p>"},{"location":"Commands/introduction/#execute","title":"<code>execute</code>","text":"<p>This gets called every tick. Put recurring actions in here, such as PID loops.</p>"},{"location":"Commands/introduction/#finished","title":"<code>finished</code>","text":"<p>This gets checked after executing, and if it's <code>true</code>, the command finishes and stops getting run and is descheduled. This is not the deepest thing in the world.</p>"},{"location":"Commands/introduction/#suspend-and-resume","title":"<code>suspend</code> and <code>resume</code>","text":"<p>These get called when the command scheduler suspends a command and resumes it, respectively. Suspension can happen for a variety of reasons, which are documented here.</p>"},{"location":"Commands/introduction/#end","title":"<code>end</code>","text":"<p>This gets called when the command ends (\ud83d\ude31). If <code>canceled</code> is <code>true</code>, that means another command interrupted this one.</p>"},{"location":"Commands/introduction/#conflict-resolution-stuff","title":"Conflict resolution stuff","text":"<p>For more info about the conflict resolution system, read conflicts.</p>"},{"location":"Commands/introduction/#configuration","title":"Configuration","text":"<p>For one-off configurations, there exists</p> <pre><code>fun &lt;T : Command&gt; T.setPriority(priority: Priority): T\nfun &lt;T : Command&gt; T.setOnHigherConflict(onHigherConflict: OnHigherConflict): T\nfun &lt;T : Command&gt; T.setOnEqualConflict(onEqualConflict: OnEqualConflict): T\n</code></pre> <p>which you can call like</p> <pre><code>val cmd = WaitCommand(3.seconds).setPriority(5.priority)\n</code></pre> <p>Note the usage of generics for this; those ensure that the \"in\" type always matches the \"out\" type, if you imagine it as sort of a pipeline. This means that if you do the above, the result will have the correct type (<code>WaitCommand</code>, in this case) instead of the more generic <code>Command</code>.</p> <p>There's also</p> <pre><code>inline fun &lt;T : Command&gt; T.configure(configuration: T.() -&gt; Unit): T\n</code></pre> <p>which uses the idiomatic builder syntax to easily configure a command's properties. Anything you put inside the function will have an implicit <code>this</code> of the command you're calling it on, which makes it easy to set multiple properties in the same block without having to chain excessively:</p> <pre><code>val cmd = WaitCommand(4.seconds).configure {\n    priority = 5.priority\n    onHigherConflict = OnHigherConflict.CANCEL\n    name = \"My wait command :)\"\n}\n</code></pre> <p>Compare that to the equivalent code using the \"standard\" inline configuration API:</p> <p><pre><code>val cmd = WaitCommand(4.seconds)\n    .setPriority(5.priority)\n    .setOnHigherConflict(OnHigherConflict.CANCEL)\n    .setName(\"My wait command :)\")\n</code></pre> \ud83e\udd22</p> <p>it's honestly not that bad, but it's more well suited to setting single properties, not 3 all at once. Plus, you can define your own methods with receivers to set up standard configurations and pass them to <code>configure</code> as a reference, which you can't do with the other one.</p>"},{"location":"Scheduler/conflicts/","title":"Conflict resolution","text":""},{"location":"Scheduler/conflicts/#overview","title":"Overview","text":"<p>Conflict resolution in FTCLib, NextFTC, and similar libraries is very basic. ducklib introduces a rich priority system, allowing for easy implementations of input buffering, default commands, and more.</p> <p>To set the <code>priority</code> or <code>OnHigherConflict</code> or <code>OnEqualConflict</code> properties of a command, check out the command configuration page. TL;DR:</p> <pre><code>val cmd = NoOpCommand().configure {\n    priority = 1.priority\n    onEqualConflict = OnEqualConflict.QUEUE\n    onHigherConflict = OnHigherConflict.CANCEL\n}\n// or\nval cmd = NoOpCommand()\n    .setPriority(priority = 1.priority)\n    .setOnEqualConflict(OnEqualConflict.QUEUE)\n    .setOnHigherConflict(OnHigherConflict.CANCEL)\n</code></pre>"},{"location":"Scheduler/conflicts/#situation-1-no-conflicts","title":"Situation 1: no conflicts","text":"<p>Say you have a command, <code>cmd1</code>, that requires <code>subsystem1</code>. Now, you try to schedule another command, <code>cmd2</code>, that requires <code>subsystem2</code>. Since neither of their requirements overlap, everything goes smoothly, and both commands are scheduled.</p>"},{"location":"Scheduler/conflicts/#situation-1-conflicts-but-cmd2-has-higher-priority","title":"Situation 1: conflicts, but <code>cmd2</code> has higher priority","text":"<p>Now, <code>cmd2</code> requires <code>subsystem1</code>. Their requirements overlap, so we have a conflict that we need to resolve.</p> <p>The first step is to compare their priorities. In this case, <code>cmd2</code> has a higher priority than <code>cmd1</code>. This means that no matter what, <code>cmd2</code> is going to run. To do this, <code>cmd1</code> will have to be suspended or canceled, so its <code>suspend</code> function will get called to aid in a smooth handoff, and <code>cmd2</code> will take over control. When <code>cmd2</code> finishes, assuming <code>cmd1</code> got suspended and not canceled, <code>cmd1</code> will get resumed and rescheduled.</p> <p>What determines whether a command is suspendable or not is the <code>suspendable</code> property on <code>Command</code>, and is set by the command.</p>"},{"location":"Scheduler/conflicts/#situation-2-conflicts-but-cmd2-has-lower-priority","title":"Situation 2: conflicts, but <code>cmd2</code> has lower priority","text":"<p>Again, the first step is to compare their priorities. In this case, <code>cmd2</code> has a lower priority than <code>cmd1</code>. This means that no matter what, <code>cmd1</code> is going to finish running.</p> <p><code>cmd2</code> has two choices: it can give up, or it can get queued for later scheduling. By default the latter is chosen, although you can set it with one one of the configuration functions.</p>"},{"location":"Scheduler/conflicts/#situation-3-conflicts-but-they-have-equal-priority","title":"Situation 3: conflicts, but they have equal priority","text":"<p><code>cmd1</code> can't wait, and <code>cmd2</code> can't wait, so now what happens is determined by the user with one of the configuration functions. They can either make <code>cmd2</code> cancel <code>cmd1</code> with <code>OnEqualConflict.OVERRIDE</code>, or make it queue with <code>OnEqualConflict.QUEUE</code>.</p>"},{"location":"Scheduler/conflicts/#recap","title":"Recap","text":"<p>Basically, the flow is this: <pre><code>       has conflicts?\n     /               \\\n    no                yes\n    |                    \\\nschedule it!               this command priority higher, lower, or equal?\n                 _________/                          |                    \\_____________\n                /                                    |                                   \\\n            higher                                 equal                               lower\n              |                                      |                                   |\n              |                           what is OnEqualConfict?                what is OnHigherConflict?\n              |                              /               \\                    /                   \\\n              |                          OVERRIDE           QUEUE               QUEUE               CANCEL\n              |                    _____/                     |              ___/                     |\n    is conflict suspendable?  ____/                     try again later ___/                      stop trying\n    /                 \\\n  yes                  no\n   |                   |\nsuspend it         cancel it\n</code></pre> (this will become an image soon)</p>"},{"location":"Scheduler/introduction/","title":"Schedulers","text":"<p>There are two types of schedulers in ducklib, <code>TriggerScheduler</code>s and <code>CommandScheduler</code>s.</p>"},{"location":"Scheduler/introduction/#triggerscheduler","title":"<code>TriggerScheduler</code>","text":"<p>The <code>TriggerScheduler</code> handles running actions on a trigger's rising edge and falling edge. This can be used to bind actions to gamepad inputs, state changes, and similar things.</p> <p>For example, using the gamepad extension API: <pre><code>driver[ButtonInput.A]\n    .onceOnTrue({ servo.position = 0.5 }.instant(servo))\n    .onceOnFalse({ servo.position = 0.0 }.instant(servo))\n</code></pre></p> <p>Here, a command is created inline and bound to a trigger.</p>"},{"location":"Scheduler/introduction/#commandscheduler","title":"<code>CommandScheduler</code>","text":"<p>The <code>CommandScheduler</code> handles running commands, and gracefully handling requirement conflicts as they arise.</p>"},{"location":"Scheduler/introduction/#duckyscheduler","title":"<code>DuckyScheduler</code>","text":"<p><code>DuckyScheduler</code> is the default implementation of both of these in ducklib. It fully implements the priority and requirement systems in ducklib.</p> <p>You can use the companion instance:</p> <pre><code>// the rest of the imports are omitted\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnFalse\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnTrue\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.schedule\n\nclass MyOpMode : OpMode {\n    fun initialize() {\n        val cmd = NoOpCommand()\n        // uses the DuckyScheduler companion instance\n        cmd.schedule()\n    }\n}\n</code></pre> <p>or make your own:</p> <pre><code>import com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnFalse\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnTrue\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.schedule\n\nclass MyOpMode : OpMode {\n    val cs = DuckyScheduler()\n\n    fun initialize() {\n        val cmd = NoOpCommand()\n        // uses the custom instance\n        with (cs) {\n            cmd.schedule()\n        }\n    }\n}\n</code></pre> <p>This is commonly done for thread-safety, since <code>DuckyScheduler</code> isn't thread-safe by itself.</p>"},{"location":"Triggers/introduction/","title":"Triggers","text":""},{"location":"Triggers/introduction/#introduction","title":"Introduction","text":"<p>Unlike in FTCLib and NextFTC, triggers in ducklib are any <code>() -&gt; Boolean</code>-typed functions. No need to wrap them in a class, just use them as-is.</p>"},{"location":"Triggers/introduction/#binding-actions-and-commands","title":"Binding actions and commands","text":"<p>Binding actions (<code>() -&gt; Unit</code>-typed functions) to triggers involves using the <code>TriggerScheduler</code>'s various binding functions.</p>"},{"location":"Triggers/introduction/#onceontrueonceonfalse","title":"<code>onceOnTrue</code>/<code>onceOnFalse</code>","text":"<p>These functions will run the action or schedule the command on the rising and falling edge of the supplier respectively.</p>"},{"location":"Triggers/introduction/#whileontrue","title":"<code>whileOnTrue</code>","text":"<p>This function accepts an action to run on the rising edge and on the falling edge. It's a convenience method for</p> <pre><code>trigger.onceOnTrue { /* do something */ }.onceOnFalse { /* do something else */ }\n</code></pre> <p>The command overload schedules the command on the rising edge and cancels it on the falling edge. If you want it to do the opposite, invert the trigger:</p> <pre><code>(!trigger).whileOnTrue(cmd)\n</code></pre>"},{"location":"Triggers/introduction/#deferred-variants","title":"Deferred variants","text":"<p>All the command-accepting <code>onceOn*</code> and <code>whileOnTrue</code> have deferred variants. These delay construction of the command until trigger time. This has some advantage over <code>DeferredCommand</code>. It's a more complete solution that doesn't require copying the requirements exactly, because the command construction happens before command initialization.</p>"}]}