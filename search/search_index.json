{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ducklib","text":""},{"location":"#why-ducklib","title":"Why ducklib?","text":"<p>Ducklib is a library made by team 14343 Escape Velocity meant to be good at scheduling commands. It's an alternative to Roadrunner Actions, FTCLib, and Dairy (at least Util and Mercurial).</p> <p>It's made to be ergonomic for most common tasks, to have a rich scheduling system while being still intuitive to those coming from FTCLib, to use idiomatic Kotlin patterns, and to keep your code concise and readable, allowing you to focus more on what you want and now how you do it.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>installation</li> <li>commands</li> <li>gamepads</li> <li>hardware maps (aka how to avoid NPEs)</li> <li>Example TeleOp</li> </ul>"},{"location":"#extra-stuff","title":"extra stuff","text":"<p>If your opmodes aren't showing up, try making them OpMode-derived instead of LinearOpModes. I don't know why this fixes it but it sure does fix it.</p>"},{"location":"example_teleop/","title":"Example TeleOp","text":"<p>Here's an example TeleOp written with ducklib for a mecanum drivebase:</p> <pre><code>package com.escapevelocity.ducklib.ftc.samples\n\nimport com.escapevelocity.ducklib.core.command.commands.LambdaCommand\nimport com.escapevelocity.ducklib.core.command.commands.instant\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnFalse\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnTrue\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.schedule\nimport com.escapevelocity.ducklib.core.command.subsystem.Subsystem\nimport com.escapevelocity.ducklib.core.geometry.*\nimport com.escapevelocity.ducklib.ftc.extensions.*\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode\nimport com.qualcomm.robotcore.hardware.DcMotor\nimport com.qualcomm.robotcore.hardware.Gamepad\nimport com.qualcomm.robotcore.hardware.Servo\n\nclass ExampleOpMode : LinearOpMode() {\n    // **NOTE**: No HardwareMap actually exists, so this is sort of like an \"empty wrapper\"\n    val map = HardwareMapEx()\n\n    // defer construction of the Servo object until the HardwareMapEx is initialized\n    val servo: Servo by map.deferred(\"motor1\")\n\n    // defer construction of DrivetrainSubsystem object until the HardwareMapEx is initialized\n    val drivetrainSubsystem by map.deferred { DrivetrainSubsystem(map) }\n\n    override fun runOpMode() {\n        // initializing the HardwareMapEx also initializes all deferred fields like `servo`\n        map.init(hardwareMap)\n\n        // alias gamepad1 to 'driver' to make things easier to understand\n        val driver = gamepad1 as Gamepad\n\n        // ButtonInputs return suppliers which can be used with onceOnTrue and onceOnFalse directly\n        driver[ButtonInput.A]\n            .onceOnTrue({ servo.position = 0.5 }.instant(servo))\n            .onceOnFalse({ servo.position = 0.0 }.instant(servo))\n\n        // use a lambda command here\n        // so we can capture the driver pad directly without having to pass in a DoubleSupplier\n        LambdaCommand {\n            execute = {\n                // driver gamepad references don't need suppliers since it's wrapped in a lambda\n                drivetrainSubsystem.drive(\n                    driver[VectorInput.STICK_LEFT].flip(Axis.Y),\n                    driver[AnalogInput.STICK_X_LEFT].radians\n                )\n            }\n            finished = { false }\n            config = {\n                // add the requirements of the drivetrain subsystem\n                // so that other commands that share that will suspend this command\n                addRequirements(drivetrainSubsystem)\n            }\n        }.schedule()\n\n        waitForStart()\n\n        while (!isStopRequested) {\n            DuckyScheduler.run()\n            telemetry.addLine(DuckyScheduler.toString())\n            telemetry.update()\n        }\n\n        DuckyScheduler.reset()\n    }\n}\n\nclass DrivetrainSubsystem(map: HardwareMapEx) : Subsystem() {\n    val flMotor: DcMotor by map.deferred(\"flMotor\")\n    val frMotor: DcMotor by map.deferred(\"frMotor\")\n    val blMotor: DcMotor by map.deferred(\"blMotor\")\n    val brMotor: DcMotor by map.deferred(\"brMotor\")\n\n    fun drive(power: Pose2) {\n        val (x, y, h) = power.xyh\n        flMotor.power = x.v - y.v - h.v\n        frMotor.power = x.v + y.v + h.v\n        blMotor.power = x.v + y.v - h.v\n        brMotor.power = x.v - y.v + h.v\n    }\n\n    fun drive(translationPower: Vector2, headingPower: Radians) =\n        drive(Pose2(translationPower, headingPower))\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Required:</p> <ul> <li>git</li> <li>some knowledge of Gradle build scripts</li> </ul>"},{"location":"installation/#step-1-cloning-ftcrobotcontroller","title":"Step 1: Cloning FtcRobotController","text":"<p>First, clone the FtcRobotController repo if you haven't already:</p> <pre><code>git clone https://github.com/FIRST-Tech-Challenge/FtcRobotController\n</code></pre>"},{"location":"installation/#step-2-cloning-ducklib","title":"Step 2: Cloning ducklib","text":"<p>Now, we'll clone ducklib into the same directory you cloned FtcRobotController into:</p> <pre><code>git clone https://github.com/escape-velocity-14343/ducklib\n</code></pre> <p>Now, your file tree should look something like this:</p> <pre><code>FTC projects folder\n\u251c FtcRobotController\n\u2502 \u251c TeamCode\n\u2502 \u251c FtcRobotController\n\u2502 ...\n\u2514 ducklib\n  \u251c ducklib\n  \u251c ducklib-ftc\n  \u251c ducklib-test\n  \u251c docs\n  ...\n</code></pre> <p>We're going to be using <code>includeBuild</code> to include a dependency to another project.</p>"},{"location":"installation/#step-3-add-projects-to-ftcrobotcontroller","title":"Step 3: Add projects to <code>FtcRobotController</code>","text":"<p>NOTE: If you clone the quickstart instead of the normal FtcRobotController (this is assuming I keep it up to date) you won't need to do this, since it already has the gradle files modified correctly.</p> <p>Now, open the <code>settings.gradle</code> file in <code>FtcRobotController</code>. You should have something like this by default:</p> <pre><code>include ':FtcRobotController'\ninclude ':TeamCode'\n</code></pre> <p>Now, add</p> <pre><code>includeBuild(\"../ducklib/ducklib\") {\n    dependencySubstitution {\n        substitute module(\"com.escapevelocity.ducklib:core\") using project(\":\")\n    }\n}\n\nincludeBuild(\"../ducklib/ducklib-ftc\") {\n    dependencySubstitution {\n        substitute module(\"com.escapevelocity.ducklib:ftc\") using project(\":\")\n    }\n}\n</code></pre> <p>to the end. This will tell Gradle to include the ducklib projects in the build as well as the normal TeamCode projects, with the package name <code>com.escapevelocity.ducklib:&lt;core/ftc&gt;</code></p>"},{"location":"installation/#step-4-add-ducklib-as-a-dependency","title":"Step 4: Add ducklib as a dependency","text":"<p>Now, you're ready to add ducklib as a dependency. Open up <code>build.gradle</code> in <code>FtcRobotController/TeamCode</code>, and add ducklib as a dependency inside the dependency block:</p> <pre><code>dependencies {\n    implementation project(':FtcRobotController')\n    implementation 'com.escapevelocity.ducklib:core'\n    implementation 'com.escapevelocity.ducklib:ftc'\n}\n</code></pre> <p>The whole <code>FtcRobotController/TeamCode/build.gradle</code> should look like this:</p> <pre><code>apply from: '../build.common.gradle'\napply from: '../build.dependencies.gradle'\napply plugin: 'org.jetbrains.kotlin.android'\n\nandroid {\n    namespace = 'org.firstinspires.ftc.teamcode'\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n\n    packagingOptions {\n        jniLibs.useLegacyPackaging true\n    }\n}\n\ndependencies {\n    implementation project(':FtcRobotController')\n    implementation 'com.escapevelocity.ducklib:core'\n    implementation 'com.escapevelocity.ducklib:ftc'\n}\n</code></pre> <p>Run a Gradle sync (tip: open up the command palette to run any action by double-pressing shift) and there shouldn't be any errors. ducklib should be ready to use!</p>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#overview","title":"Overview","text":"<p>A command represents an action. For example, an action that waits for 2 seconds:</p> <pre><code>val cmd = WaitCommand(2.0.seconds)\n</code></pre> <p>A command that runs a specified action:</p> <p><pre><code>val cmd = InstantCommand {  println(\"ducky!\") }\n</code></pre> More info on built-in commands</p> <p>A user-made command that drives the robot around:</p> <p><pre><code>val cmd = DriveCommand(mecanum, Vector2(3.inches, 5.inches))\n</code></pre> More info on custom commands</p> <p>A command that runs all of those commands in sequence</p> <p><pre><code>val cmd = SequentialCommandGroup(\n    WaitCommand(2.0.seconds),\n    InstantCommand {  println(\"ducky!\") },\n    DriveCommand(mecanum, Vector2(3.inches, 5.inches)),\n)\n</code></pre> More info on command groups</p> <p>Commands are extremely flexible because each one represents a single unit of work, and they can be composed in groups to make entire autonomi.</p> <p>Commands are run by the command scheduler. Commands can also optionally have a set of requirements and a priority.</p>"},{"location":"commands/#lifetime-functions","title":"Lifetime functions","text":"<p>Every command overrides a set of lifetime functions, which (in calling order) are:</p>"},{"location":"commands/#initialize","title":"<code>initialize</code>","text":"<p>This gets called as soon as the command gets actually scheduled, so if the scheduling gets deferred (e.g. by attempting to schedule it while the scheduler is processing commands) it'll wait until the deferred calls get run. It gets run every time the command is initialized, not just the first time.</p>"},{"location":"commands/#execute","title":"<code>execute</code>","text":"<p>This gets called every tick. Put recurring actions in here, such as PID loops.</p>"},{"location":"commands/#finished","title":"<code>finished</code>","text":"<p>This gets checked after executing, and if it's <code>true</code>, the command finishes and stops getting run and is descheduled. This is not the deepest thing in the world.</p>"},{"location":"commands/#suspend-and-resume","title":"<code>suspend</code> and <code>resume</code>","text":"<p>These get called when the command scheduler suspends a command and resumes it, respectively. Suspension can happen for a variety of reasons, which are documented here.</p>"},{"location":"commands/#end","title":"<code>end</code>","text":"<p>This gets called when the command ends (\ud83d\ude31). If <code>canceled</code> is <code>true</code>, that means another command interrupted this one.</p>"},{"location":"commands/#conflict-resolution-stuff","title":"Conflict resolution stuff","text":"<p>For more info about the conflict resolution system, read conflicts.</p>"},{"location":"commands/#configuration","title":"Configuration","text":"<p>For one-off configurations, there exists</p> <pre><code>fun &lt;T : Command&gt; T.setPriority(priority: Priority): T\nfun &lt;T : Command&gt; T.setOnHigherConflict(onHigherConflict: OnHigherConflict): T\nfun &lt;T : Command&gt; T.setOnEqualConflict(onEqualConflict: OnEqualConflict): T\n</code></pre> <p>which you can call like</p> <pre><code>val cmd = WaitCommand(3.seconds).setPriority(5.priority)\n</code></pre> <p>Note the usage of generics for this; those ensure that the \"in\" type always matches the \"out\" type, if you imagine it as sort of a pipeline. This means that if you do the above, the result will have the correct type (<code>WaitCommand</code>, in this case) instead of the more generic <code>Command</code>.</p> <p>There's also</p> <pre><code>inline fun &lt;T : Command&gt; T.configure(configuration: T.() -&gt; Unit): T\n</code></pre> <p>which uses the idiomatic builder syntax to easily configure a command's properties. Anything you put inside the function will have an implicit <code>this</code> of the command you're calling it on, which makes it easy to set multiple properties in the same block without having to chain excessively:</p> <pre><code>val cmd = WaitCommand(4.seconds).configure {\n    priority = 5.priority\n    onHigherConflict = OnHigherConflict.CANCEL\n    name = \"My wait command :)\"\n}\n</code></pre> <p>Compare that to the equivalent code using the \"standard\" inline configuration API:</p> <p><pre><code>val cmd = WaitCommand(4.seconds)\n    .setPriority(5.priority)\n    .setOnHigherConflict(OnHigherConflict.CANCEL)\n    .setName(\"My wait command :)\")\n</code></pre> \ud83e\udd22</p> <p>it's honestly not that bad, but it's more well suited to setting single properties, not 3 all at once. Plus, you can define your own methods with receivers to set up standard configurations and pass them to <code>configure</code> as a reference, which you can't do with the other one.</p>"},{"location":"commands/builtin/","title":"Built-in commands","text":"<p>ducklib comes with a number of commands built in as basic utilities.</p>"},{"location":"commands/builtin/#atomic-commands","title":"Atomic commands","text":""},{"location":"commands/builtin/#instantcommand","title":"<code>InstantCommand</code>","text":"<p>It runs a lambda once in <code>execute</code> and then stops.</p> <p>Example usage:</p> <pre><code>val cmd = InstantCommand { println(\"duck\") }\n</code></pre> <p>Alternatively, with the decorator:</p> <pre><code>val cmd = { println(\"duck\") }.instant()\n</code></pre> <p>You can also give both of these a set of requirements:</p> <pre><code>val cmd = InstantCommand(requirement) { println(\"duck\") }\n</code></pre> <pre><code>val cmd = { println(\"duck\") }.instant(requirement)\n</code></pre>"},{"location":"commands/builtin/#loopcommand","title":"<code>LoopCommand</code>","text":"<p>Not to be confused with <code>RepeatCommand</code>, it calls the given lambda repeatedly forever. Think if it like a non-instant <code>InstantCommand</code>.</p> <p>Example usage:</p> <pre><code>val cmd = LoopCommand { println(\"duck\") }\n</code></pre> <p>Alternatively, with the decorator:</p> <pre><code>val cmd = { println(\"duck\") }.loop()\n</code></pre> <p>You can also give both of these a set of requirements:</p> <pre><code>val cmd = LoopCommand(requirement) { println(\"duck\") }\n</code></pre> <pre><code>val cmd = { println(\"duck\") }.loop(requirement)\n</code></pre> <p>If you want to repeat a lambda finitely, compose an <code>InstantCommand</code> inside a <code>RepeatCommand</code> instead.</p>"},{"location":"commands/builtin/#noopcommand","title":"<code>NoOpCommand</code>","text":"<p>it does nothing, like me.</p>"},{"location":"commands/builtin/#waitcommand","title":"<code>WaitCommand</code>","text":"<p>It waits for a given number of seconds, optionally accounting for suspension time as well (e.g. if it has a 2 second timer, has been running for 1 second, gets suspended for 5 seconds, then resumes, it'll continue waiting for 1 second)</p>"},{"location":"commands/builtin/#waituntilcommand","title":"<code>WaitUntilCommand</code>","text":"<p>It waits until a condition is true.</p>"},{"location":"commands/builtin/#lambdacommand","title":"<code>LambdaCommand</code>","text":"<p>A command that delegates the functions to lambda-typed properties.</p> <p>It's useful for creating inline one-off commands that don't really get used anywhere else.</p> <p>For example, a driving command that captures a subsystem reference and gamepad in the lambda:</p> <pre><code>LambdaCommand {\n    execute = {\n        // driver gamepad references don't need suppliers since it's wrapped in a lambda\n        drivetrainSubsystem.drive(\n            driver[VectorInput.STICK_LEFT].flip(Axis.Y),\n            driver[AnalogInput.STICK_X_LEFT].radians\n        )\n    }\n    finished = { false }\n    config = {\n        // add the requirements of the drivetrain subsystem\n        // so that other commands that share that will suspend this command\n        addRequirements(drivetrainSubsystem)\n    }\n}.schedule()\n</code></pre> <p>Note the <code>config = {</code>. This is needed because, for improved naming, when you call the <code>LambdaCommand(configuration)</code> constructor, the configuration lambda's receiver object is actually of the type <code>LambdaCommandBuilder</code> which aliases some of the properties of <code>LambdaCommand</code>. This is because the function-typed variables are prefixed with <code>lm-</code> to avoid name overlaps in <code>LambdaCommand</code>. However, this means that you can't configure the <code>Command</code>-specific properties like requirements and priority in the lambda. To fix this, simply put those inside of <code>config</code>, which will get called with the receiver of the constructed <code>LambdaCommand</code>:</p> <pre><code>LambdaCommand {\n    // LambdaCommandBuilder - aliased names\n    finished = { true }\n    config = {\n        // LambdaCommand - non-aliased names.\n        // Note that this runs *after* the rest of the configuration is copied over.\n        priority = 5.priority\n        addRequirements(ss1)\n    }\n}\n</code></pre> <p>You can also capture state inside of the configuration lambda, removing the need for a <code>StatefulLambda</code> like Mercurial has:</p> <pre><code>LambdaCommand {\n    var i = 0\n    initialize = { i = 0 }\n    execute = { i += 1 }\n    finished = { i &gt;= 5 }\n}\n</code></pre>"},{"location":"commands/builtin/#compositions","title":"Compositions","text":"<p>Composition commands compose a set of commands, inheriting most of their functionality while overriding specific actions.</p>"},{"location":"commands/builtin/#deferredcommand","title":"<code>DeferredCommand</code>","text":"<p><code>DeferredCommand</code> defers command construction (through <code>commandSupplier</code>) until initialization time. It's useful when you're making a command that has dynamically changing values, such as a path generator.</p> <p>Example usage: <pre><code>val cmd = DeferredCommand { WaitCommand(getSomeDynamicWaitTime()) }\n</code></pre> In this example, construction of the <code>WaitCommand</code> is deferred until the command is initialized, so even though <code>WaitCommand</code> doesn't accept a time supplier, the amount of time it waits can change. Note how this is fundamentally different from <pre><code>val cmd = WaitCommand(getSomeDynamicWaitTime())\n</code></pre> since that will compute the wait time once and use that every time it's scheduled.</p>"},{"location":"commands/builtin/#ifcommand-ifelsecommand-and-whencommand","title":"<code>IfCommand</code>, <code>IfElseCommand</code>, and <code>WhenCommand</code>","text":"<p><code>IfCommand</code> runs a command if, at initialization time, the provided supplier returns <code>true</code>.</p> <p>Example usage: <pre><code>val cmd = IfCommand({ slidesRetracted }, extend())\n</code></pre> In this example, if <code>slidesRetracted</code> is <code>true</code>, if the command is run something will extend, otherwise nothing will happen.</p> <p><code>IfElseCommand</code> runs a command if, at initialization time, the provided supplier returns <code>true</code>, otherwise it runs the other command.</p> <p>Example usage: <pre><code>val cmd = IfCommand({ slidesRetracted }, extend(), retract())\n</code></pre> In this example, if <code>slidesRetracted</code> is <code>true</code>, if the command is run something will extend, otherwise something will retract.</p> <p><code>WhenCommand</code> selects a command to run based on the provided supplier.</p> <p>Example usage: <pre><code>val cmd = WhenCommand { state }.configure {\n    this[State.READY] = outtake()\n    this[State.INTAKE] = retract() then outtake()\n    this[State.HANG] = retract() then outtake()\n    default = retract()\n}\n</code></pre> For more information on the <code>configure</code> method, see configure</p> <p>It also has an alternative syntax:</p> <pre><code>val cmd = WhenCommand(\n    State.READY to outtake(),\n    State.INTAKE to retract() then outtake(),\n    State.HANG to retract() then outtake(),\n    default = retract()\n) { state }\n</code></pre>"},{"location":"commands/builtin/#timeoutcommand","title":"<code>TimeoutCommand</code>","text":"<p><code>TimeoutCommand</code> adds a timeout to the command.</p> <p>Example usage</p> <pre><code>val cmd = TimeoutCommand(WaitCommand(5.seconds), 3.seconds)\n</code></pre> <p>Alternatively, use the decorator:</p> <pre><code>val cmd = WaitCommand(5.seconds).withTimeout(3.seconds)\n</code></pre>"},{"location":"commands/builtin/#repeatcommand","title":"<code>RepeatCommand</code>","text":"<p><code>RepeatCommand</code> runs a command repeatedly, either for some finite number of repeats, or forever.</p> <p>Example usage:</p> <pre><code>// repeat 3 times\nval cmd = RepeatCommand(WaitCommand(3.seconds), 3)\n</code></pre> <pre><code>// repeat infinite times\nval cmd = RepeatCommand(WaitCommand(3.seconds))\n</code></pre> <p>Alternatively, use the decorator:</p> <pre><code>// repeat 3 times\nval cmd = WaitCommand(3.seconds).repeat(3)\n</code></pre> <pre><code>// repeat infinite times\nval cmd = WaitCommand(3.seconds).forever\n</code></pre> <p>This is especially useful for <code>InstantCommand</code>s:</p> <pre><code>val cmd = { println(\"duck!\") }.instant().forever\n</code></pre>"},{"location":"commands/builtin/#groups","title":"Groups","text":"<p>See command groups</p>"},{"location":"commands/groups/","title":"Command groups","text":""},{"location":"commands/groups/#introduction","title":"Introduction","text":"<p>Command groups are a special type of composing command that group together commands in useful ways.</p>"},{"location":"commands/groups/#sequentialcommandgroup","title":"<code>SequentialCommandGroup</code>","text":"<p>The most common type of command group. It runs a set of commands, one after the other, and finishes when the last one finishes.</p> <p>For example, a command that says \"hi\", waits 5 seconds, then says \"bye\":</p> <pre><code>val cmd = SequentialCommandGroup(\n    { println(\"hi\") }.instant(),\n    WaitCommand(5.seconds),\n    { println(\"bye\") }.instant(),\n)\n</code></pre> <p>You can also construct this with the <code>then</code> infix operator:</p> <pre><code>val cmd = { println(\"hi\") }.instant() then WaitCommand(5.seconds) and { println(\"bye\") }.instant()\n</code></pre>"},{"location":"commands/groups/#parallelcommandgroup","title":"<code>ParallelCommandGroup</code>","text":"<p>The second most common type of command group. It runs a set of commands all at the same time, and finishes when they're all finished.</p> <p>For example, a command that says \"hi\" and \"bye\" at the same time:</p> <pre><code>val cmd = ParallelCommandGroup(\n    { println(\"hi\") }.instant(),\n    { println(\"bye\") }.instant(),\n)\n</code></pre> <p>You can also construct this with the <code>with</code> infix operator:</p> <pre><code>val cmd = { println(\"hi\") }.instant() with { println(\"bye\") }.instant()\n</code></pre>"},{"location":"commands/groups/#parallelcommandgroup-like-groups","title":"<code>ParallelCommandGroup</code>-like groups","text":"<p>There are a bunch of groups that act similar to <code>ParallelCommandGroup</code> but have different end conditions.</p>"},{"location":"commands/groups/#racecommandgroup","title":"<code>RaceCommandGroup</code>","text":"<p>This group runs all the commands at the same time and ends when any one of them ends.</p> <p>For example, a group that waits for 4 seconds:</p> <pre><code>val cmd = RaceCommandGroup(\n    WaitCommand(4.seconds),\n    WaitCommand(5.seconds),\n)\n</code></pre> <p>You can also construct this with the <code>races</code> infix operator:</p> <pre><code>val cmd = WaitCommand(4.seconds) races WaitCommand(5.seconds) and WaitCommand(6.seconds)\n</code></pre>"},{"location":"commands/groups/#deadlinecommandgroup","title":"<code>DeadlineCommandGroup</code>","text":"<p>This group ends when the \"deadline\" command finishes.</p> <p>For example, a group that runs for exactly 5 seconds all the while printing \"duck\":</p> <pre><code>val cmd = DeadlineCommandGroup(\n    WaitCommand(5.seconds),\n    { println(\"duck\") }.loop()\n)\n</code></pre> <p>A group that runs for 5 seconds but only prints \"duck\" onceL</p> <pre><code>val cmd = DeadlineCommandGroup(\n    WaitCommand(5.seconds),\n    { println(\"duck\") }.instant()\n)\n</code></pre> <p>You can also construct this with the <code>deadlines</code> operator. Note that unlike the <code>then</code>, <code>with</code>, <code>parallel</code>, and <code>races</code> operators, you have to use <code>and</code> to chain multiple commands in the group.</p> <pre><code>val cmd = WaitCommand(5.seconds) deadlines { println(\"duck\") }.loop()\n</code></pre> <p>Also, <code>DeadlineCommandGroup</code>s may seem very similar to <code>RaceCommandGroup</code> but they are not the same. <code>RaceCommandGroup</code> ends when any of the commands end, but <code>DeadlineCommandGroup</code> only ends when the deadline command ends.</p>"},{"location":"commands/groups/#infix-operators","title":"Infix operators","text":"<p>Command groups also have some utility infix operators that make your command groups read more like English. They are as follows:</p> <ul> <li><code>then</code>: SequentialCommandGroup</li> <li><code>with</code>: ParallelCommandGroup</li> <li><code>races</code>: RaceCommandGroup</li> <li><code>deadlines</code>: DeadlineCommandGroup</li> <li><code>and</code>: Adds the command on the right to the command group on the left</li> </ul> <p>Like all Kotlin infix operators, they all have the same precedence and are left-associative. This means that</p> <pre><code>cmd1 then cmd2 with cmd3 and cmd4 deadlines cmd5\n</code></pre> <p>is parsed as</p> <pre><code>(((cmd1 then cmd2) with cmd3) and cmd4) deadlines cmd5\n</code></pre> <p>and no other way.</p> <p><code>then</code>, <code>with</code>, and <code>races</code> will automatically check if the command on the left is a group of the right type, and if it is, it adds the command on the right instead of creating nested groups. However, this doesn't work with DeadlineCommandGroup because the command on the left is always the deadline command, so you have to use <code>and</code> with that one.</p> <p>In my opinion, <code>and</code> makes the code easier to read, so I suggest using it. For example, this:</p> <pre><code>cmd1 with cmd2 and cmd3 and cmd3\n</code></pre> <p>is more readable than</p> <pre><code>cmd1 with cmd2 with cmd3 with cmd4\n</code></pre>"},{"location":"ftc/dashboard/","title":"FTC Dashboard integration","text":"<p>If FTC dashboard is installed, you can use the FTC dashboard extensions.</p>"},{"location":"ftc/dashboard/#dashboard-properties","title":"Dashboard properties","text":"<p>Instead of using <code>@Config</code>,  ducklib includes support for a dashboard-delegated property. The syntax is like this:</p> <pre><code>val dashProperty by DashboardEx[\"category/dashProperty\", 0]\n</code></pre> <p>where the first parameter is the name and the second is the initial value for the property. If no category is specified, the property will go in the category \"Config\".</p> <p>When you change the value in FTC Dashboard ((local ip address)[192.168.43.1:8080/dash]) it will update the value:</p> <pre><code>package org.firstinspires.ftc.teamcode.opmode\n\nimport com.escapevelocity.ducklib.ftc.extensions.DashboardEx\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp\n\n@TeleOp\nclass CustomOpMode : OpMode() {\n    val dashConstant by DashboardEx[\"category/dashConstant\", 0.0]\n\n    override fun loop() {\n        telemetry.addData(\"dashboard\", dashConstant)\n    }\n}\n</code></pre>"},{"location":"ftc/gamepad/","title":"Gamepad extensions","text":"<p>ducklib introduces some utility extension methods on <code>Gamepad</code>, which together aim to create a more ergonomic interface for binding actions and commands to driver input.</p> <p>Check out the example TeleOp for some real-world situations.</p>"},{"location":"ftc/gamepad/#button-binding","title":"Button binding","text":"<p>You can bind an action to a button like this:</p> <pre><code>gamepad1[ButtonInput.TRIANGLE].onceOnTrue(cmd)\n</code></pre> <p>Now, if you've read the triggers page, you should know that triggers in ducklib are just <code>() -&gt; Boolean</code>-typed functions. This means that <code>gamepad1[ButtonInput.TRIANGLE]</code> is actually returning a lambda, which means you can store it in a variable, pass it around to other methods, and do all the normal things you'd do to lambdas as this. It also means you can get the current state of the input by calling it immediately:</p> <pre><code>val v = gamepad1[ButtonInput.TRIANGLE]()\n</code></pre> <p>although that's why <code>current</code> exists:</p> <pre><code>val v = gamepad1.current(ButtonInput.TRIANGLE)\n</code></pre> <p>so use that instead.</p> <p>Most of the button names are pulled straight from the SDK, although some are changed for clarity and convention.</p>"},{"location":"ftc/gamepad/#analog-and-vector-binding","title":"Analog and vector binding","text":"<p>Only getting button inputs returns a function type, analog and vector gets return the actual value:</p> <pre><code>val driveCmd = LambdaCommand {\n    addRequirements(drivetrainSubsystem)\n    lmexecute = {\n        drivetrainSubsystem.drive(\n            driver[VectorInput.STICK_LEFT].flip(Axis.Y),\n            driver[AnalogInput.STICK_X_LEFT].radians\n        )\n    }\n    lmfinished = { false }\n}\n</code></pre>"},{"location":"ftc/gamepad/#converting-analog-inputs-into-triggers","title":"Converting analog inputs into triggers","text":"<p>Sometimes you want to make a trigger that's based on a threshold, say for when the gamepad trigger is depressed 50%. You can wrap those in lambdas:</p> <pre><code>({ gamepad1[AnalogInput.STICK_Y_LEFT] &gt; 0.5 }).onceOnTrue(cmd)\n</code></pre> Why the parenthesis? They're to avoid parser ambiguities like this:  <pre><code>val idk = duck()\n\n{ x }\n\n// could be parsed as\n\n/* statement  */ val idk = duck() { x }\n\n// or\n\n/* statement  */ val idk = duck()\n/* expression */ { x }\n</code></pre>  since if a function has a function-typed parameter as the last parameter, you can move the argument out of the parenthesis.  <p>  You can see that the latter is what we want, but the compiler doesn't know that since it's trying to be as whitespace-agnostic as a Kotlin compiler can be.  <p>Also, if you're okay with the default threshold of 0.5, you can use the <code>bool</code> utility methods:</p> <pre><code>// triggers when value &gt; 0.5\n({ gamepad1[AnalogInput.STICK_Y_LEFT] }).bool().onceOnTrue(cmd)\n\n// triggers when length &gt; 0.5\n({ gamepad1[VectorInput.STICK_LEFT] }).bool().onceOnTrue(cmd)\n</code></pre>"},{"location":"ftc/hardware_map/","title":"Hardware map extensions","text":""},{"location":"ftc/hardware_map/#key-features","title":"Key features","text":"<p>ducklib includes a hardware map extension class to make using the hardware map a little easier. The main pain points that can be (and are) resolved with Kotlin are as follows</p> <ul> <li>Having to pass in a class instance, like <code>hardwareMap.get(Servo::class, \"servo\")</code></li> <li>No type inference</li> <li>Hardware access classes not being able to be final, since they get set in <code>initialize</code></li> </ul> <p>ducklib's <code>HardwareMapEx</code> class solves all of these problems.</p>"},{"location":"ftc/hardware_map/#usage","title":"Usage","text":"<p>Create a variable named whatever you want at the OpMode-class-level:</p> <pre><code>class MyOpMode : LinearOpMode() {\n    val map = HardwareMapEx()\n    // etc.\n}\n</code></pre> Why can't it be wrapped in the initializer?         This is because it doesn't get fully set until the `OpMode` is initialized.         Technically there are ways around that but it works fine without it,         which you'll see in a bit.  <p>Now, no <code>HardwareMap</code> instance has been wrapped yet, and this is intentional. If you're familiar to <code>lateinit var</code>s in Kotlin, it's kind of similar to that.</p> <p>To fully initialize the map, call <code>init</code>:</p> <pre><code>override fun runOpMode() {\n    map.init(hardwareMap)\n}\n</code></pre>"},{"location":"ftc/hardware_map/#standard-usage","title":"Standard usage","text":"<p>Like the normal <code>HardwareMap</code>, <code>HardwareMapEx</code> supports get methods:</p> <pre><code>val servo: Servo = map.get&lt;Servo&gt;(\"servo\")\n</code></pre> <p>However, note how you don't need to pass a <code>Servo::class</code> instance to <code>map.get</code>. This is because that function uses a reified type parameter, significantly simplifying the code. This also means you get some type inference:</p> <pre><code>val servo = map.get&lt;Servo&gt;(\"servo\")\n</code></pre> <p>or</p> <pre><code>val servo: Servo = map[\"servo\"]\n</code></pre> <p>but not</p> <pre><code>val servo = map.get[\"servo\"]\n</code></pre> <p>since then no types are defined. Personally, I prefer the second option since it more clearly communicates the type of the variable, and it also allows you to use the more idiomatic subscripting operator.</p>"},{"location":"ftc/hardware_map/#deferred-hardware-references","title":"Deferred hardware references","text":"<p>Since <code>map</code> isn't initialized until <code>runOpMode</code>, it makes it somewhat problematic to set references. For example, in Java you'd have to do</p> <pre><code>Servo servo;\n\n@Override\nvoid runOpMode() {\n    servo = hardwareMap.get(Servo::class, \"servo\");\n}\n</code></pre> <p>However, this moves initialization far from the ~~center of rotation~~ variable declaration, which makes the code less readable. That's why <code>HardwareMapEx</code> supports hardware-read delegated values:</p> <pre><code>val servo: Servo by map.deferred(\"servo\")\n</code></pre> <p>The improvement here is that the types are closer together and only declared once, and the hardware name of the servo is closer to the declaration of the variable. This makes the code more readable overall, since you have to hunt around for usages less. But, you may ask, how does it know what the object is?</p> <p>The Servo instance isn't actually configured until <code>map</code> is initialized with <code>init</code>! When you call <code>map.init(hardwareMap)</code>, it actually does two things</p> <ol> <li>set the internal reference hardware map to the passed hardware map</li> <li>initialize all deferred properties</li> </ol> <p>Accessing a hardware map-delegated property before it's initialized will result in an exception! Don't try to!</p>"},{"location":"ftc/hardware_map/#deferred-initialization","title":"Deferred initialization","text":"<p>\"But then\",</p> <p>you may ask,</p> <p>\"how can you keep instancing of subsystems close to the declaration as well? This:</p> <pre><code>val servo: Servo by map.deferred(\"servo\")\n\nval subsystem = ServoSubsystem(servo) // exception \ud83e\udd3e!\n</code></pre> <p>won't work because it's accessing the hardware-referencing variable before it's declared.\"</p> <p>ducklib has thought of that too. Simply use the overload that accepts a <code>() -&gt; T</code> instead of the normal hardware access overload like so:</p> <pre><code>val servo: Servo by map.deferred(\"servo\")\n\nval subsystem by map.deferred { ServoSubsystem(servo) }\n</code></pre> <p>Note how all the types are inferred, keeping the code clean and concise.</p>"},{"location":"scheduler/","title":"Schedulers","text":"<p>There are two types of schedulers in ducklib, <code>TriggerScheduler</code>s and <code>CommandScheduler</code>s.</p>"},{"location":"scheduler/#triggerscheduler","title":"<code>TriggerScheduler</code>","text":"<p>The <code>TriggerScheduler</code> handles running actions on a trigger's rising edge and falling edge. This can be used to bind actions to gamepad inputs, state changes, and similar things.</p> <p>For example, using the gamepad extension API: <pre><code>driver[ButtonInput.A]\n    .onceOnTrue({ servo.position = 0.5 }.instant(servo))\n    .onceOnFalse({ servo.position = 0.0 }.instant(servo))\n</code></pre></p> <p>Here, a command is created inline and bound to a trigger.</p>"},{"location":"scheduler/#commandscheduler","title":"<code>CommandScheduler</code>","text":"<p>The <code>CommandScheduler</code> handles running commands, and gracefully handling requirement conflicts as they arise.</p>"},{"location":"scheduler/#duckyscheduler","title":"<code>DuckyScheduler</code>","text":"<p><code>DuckyScheduler</code> is the default implementation of both of these in ducklib. It fully implements the priority and requirement systems in ducklib.</p> <p>You can use the companion instance:</p> <pre><code>// the rest of the imports are omitted\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnFalse\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnTrue\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.schedule\n\nclass MyOpMode : OpMode {\n    fun initialize() {\n        val cmd = NoOpCommand()\n        // uses the DuckyScheduler companion instance\n        cmd.schedule()\n    }\n}\n</code></pre> <p>or make your own:</p> <pre><code>import com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnFalse\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.onceOnTrue\nimport com.escapevelocity.ducklib.core.command.scheduler.DuckyScheduler.Companion.schedule\n\nclass MyOpMode : OpMode {\n    val cs = DuckyScheduler()\n\n    fun initialize() {\n        val cmd = NoOpCommand()\n        // uses the custom instance\n        with (cs) {\n            cmd.schedule()\n        }\n    }\n}\n</code></pre> <p>This is commonly done for thread-safety, since <code>DuckyScheduler</code> isn't thread-safe by itself.</p>"},{"location":"scheduler/conflicts/","title":"Conflict resolution","text":""},{"location":"scheduler/conflicts/#overview","title":"Overview","text":"<p>Conflict resolution in FTCLib, NextFTC, and similar libraries is very basic. ducklib introduces a rich priority system, allowing for easy implementations of input buffering, default commands, and more.</p> <p>To set the <code>priority</code> or <code>OnHigherConflict</code> or <code>OnEqualConflict</code> properties of a command, check out the command configuration page. TL;DR:</p> <pre><code>val cmd = NoOpCommand().configure {\n    priority = 1.priority\n    onEqualConflict = OnEqualConflict.QUEUE\n    onHigherConflict = OnHigherConflict.CANCEL\n}\n// or\nval cmd = NoOpCommand()\n    .setPriority(priority = 1.priority)\n    .setOnEqualConflict(OnEqualConflict.QUEUE)\n    .setOnHigherConflict(OnHigherConflict.CANCEL)\n</code></pre>"},{"location":"scheduler/conflicts/#situation-1-no-conflicts","title":"Situation 1: no conflicts","text":"<p>Say you have a command, <code>cmd1</code>, that requires <code>subsystem1</code>. Now, you try to schedule another command, <code>cmd2</code>, that requires <code>subsystem2</code>. Since neither of their requirements overlap, everything goes smoothly, and both commands are scheduled.</p>"},{"location":"scheduler/conflicts/#situation-1-conflicts-but-cmd2-has-higher-priority","title":"Situation 1: conflicts, but <code>cmd2</code> has higher priority","text":"<p>Now, <code>cmd2</code> requires <code>subsystem1</code>. Their requirements overlap, so we have a conflict that we need to resolve.</p> <p>The first step is to compare their priorities. In this case, <code>cmd2</code> has a higher priority than <code>cmd1</code>. This means that no matter what, <code>cmd2</code> is going to run. To do this, <code>cmd1</code> will have to be suspended or canceled, so its <code>suspend</code> function will get called to aid in a smooth handoff, and <code>cmd2</code> will take over control. When <code>cmd2</code> finishes, assuming <code>cmd1</code> got suspended and not canceled, <code>cmd1</code> will get resumed and rescheduled.</p> <p>What determines whether a command is suspendable or not is the <code>suspendable</code> property on <code>Command</code>, and is set by the command.</p>"},{"location":"scheduler/conflicts/#situation-2-conflicts-but-cmd2-has-lower-priority","title":"Situation 2: conflicts, but <code>cmd2</code> has lower priority","text":"<p>Again, the first step is to compare their priorities. In this case, <code>cmd2</code> has a lower priority than <code>cmd1</code>. This means that no matter what, <code>cmd1</code> is going to finish running.</p> <p><code>cmd2</code> has two choices: it can give up, or it can get queued for later scheduling. By default the latter is chosen, although you can set it with one one of the configuration functions.</p>"},{"location":"scheduler/conflicts/#situation-3-conflicts-but-they-have-equal-priority","title":"Situation 3: conflicts, but they have equal priority","text":"<p><code>cmd1</code> can't wait, and <code>cmd2</code> can't wait, so now what happens is determined by the user with one of the configuration functions. They can either make <code>cmd2</code> cancel <code>cmd1</code> with <code>OnEqualConflict.OVERRIDE</code>, or make it queue with <code>OnEqualConflict.QUEUE</code>.</p>"},{"location":"scheduler/conflicts/#recap","title":"Recap","text":"<p>Basically, the flow is this:</p> <pre><code>graph TB\n  Start(Command wants to get scheduled) --&gt; HasConflicts\n  HasConflicts{Has conflicts?} --&gt;|Yes| ConflictPriority{Conflicting command's priority higher, lower or equal?}\n  ConflictPriority --&gt;|Higher| HigherConflict{What is &lt;code&gt;OnHigherConflict&lt;/code&gt;?}\n  Queue(Queue for rescheduling attempt next tick)\n  HigherConflict --&gt;|CANCEL| HigherConflictEnd(Stop trying, cancel scheduling)\n  HigherConflict --&gt;|QUEUE| Queue\n  ConflictPriority --&gt;|Equal| EqualConflict{What is &lt;code&gt;OnEqualConflict&lt;/code&gt;?}\n  EqualConflict --&gt;|QUEUE| Queue\n  ConflictPriority --&gt;|Lower| SuspendOrCancel\n  SuspendOrCancel{Is conflict suspendable?}\n  SuspendOrCancelSuspendable(Suspend the conflict) --&gt; ScheduleCommand\n  SuspendOrCancelUnsuspendable(Cancel the conflict) --&gt; ScheduleCommand\n  SuspendOrCancel --&gt;|Yes| SuspendOrCancelSuspendable\n  SuspendOrCancel --&gt;|No| SuspendOrCancelUnsuspendable\n  EqualConflict --&gt;|OVERRIDE| SuspendOrCancel\n  ScheduleCommand(Command gets scheduled)\n  Queue -.-&gt;|after one tick| Start</code></pre>"},{"location":"triggers/","title":"Triggers","text":""},{"location":"triggers/#introduction","title":"Introduction","text":"<p>Unlike in FTCLib and NextFTC, triggers in ducklib are any <code>() -&gt; Boolean</code>-typed functions. No need to wrap them in a class, just use them as-is.</p>"},{"location":"triggers/#binding-actions-and-commands","title":"Binding actions and commands","text":"<p>Binding actions (<code>() -&gt; Unit</code>-typed functions) to triggers involves using the <code>TriggerScheduler</code>'s various binding functions.</p>"},{"location":"triggers/#onceontrueonceonfalse","title":"<code>onceOnTrue</code>/<code>onceOnFalse</code>","text":"<p>These functions will run the action or schedule the command on the rising and falling edge of the supplier respectively.</p>"},{"location":"triggers/#whileontrue","title":"<code>whileOnTrue</code>","text":"<p>This function accepts an action to run on the rising edge and on the falling edge. It's a convenience method for</p> <pre><code>trigger.onceOnTrue { /* do something */ }.onceOnFalse { /* do something else */ }\n</code></pre> <p>The command overload schedules the command on the rising edge and cancels it on the falling edge. If you want it to do the opposite, invert the trigger:</p> <pre><code>(!trigger).whileOnTrue(cmd)\n</code></pre>"},{"location":"triggers/#deferred-variants","title":"Deferred variants","text":"<p>All the command-accepting <code>onceOn*</code> and <code>whileOnTrue</code> have deferred variants. These delay construction of the command until trigger time. This has some advantage over <code>DeferredCommand</code>. It's a more complete solution that doesn't require copying the requirements exactly, because the command construction happens before command initialization.</p>"}]}